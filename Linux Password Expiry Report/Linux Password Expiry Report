// =======================================
// Pre Block : Initialization & Input Data
// =======================================

// Set current date for file naming and email subject
//def oldcurrentdate = new Date().format("dd-MMM-YY HH:mm:ss")
//inputMap.oldcurrentdate = oldcurrentdate


def tz = TimeZone.getTimeZone("Asia/Kolkata")
def currentdateTime = new Date().format("dd-MMM-yy HH:mm:ss", tz)
inputMap.currentdate = currentdateTime

 
 
// Fetch email subject from reference table and append date
def subject = RefDataQuery.from("Linux_Mail_Recipients").where(RefDataCriteria.exp("key").equalTo("subject")).execute()[0].values.trim()
inputMap.emailsubject = "Linux Password Expiry Report - " + currentdateTime
//inputMap.emailsubject = "Linux Password Expiry Report (IST: " + currentdateTime + ", GMT: " + oldcurrentdate + ")"

 
// Fetch "To" recipients list from reference table
def to = RefDataQuery.from("Linux_Mail_Recipients").where(RefDataCriteria.exp("key").equalTo("emailto")).execute()[0].values.trim()
inputMap.emailTo = to
 
// Fetch "CC" recipients list from reference table
def cc = RefDataQuery.from("Linux_Mail_Recipients").where(RefDataCriteria.exp("key").equalTo("emailcc")).execute()[0].values.trim()
inputMap.emailCC = cc

// Get all user-email mappings from ref data and build a map
def userEmailMap = [:]
/*def emailRows = RefDataQuery.from("Linux_User_Email_Map").execute()
emailRows.each { row ->
    def username = row["username"]?.trim()?.toLowerCase()
    def email = row["email"]?.trim()
    if (username && email) {
        userEmailMap[username] = email
    }
}*/

def emailRows = RefDataQuery.from("Linux_User_Email_Map").execute()
emailRows.each { row ->
    def username = row["username"]?.trim()?.toLowerCase()
    def toEmail = row["tomail"]?.trim()
    def ccEmail = row["ccmail"]?.trim()
    def supportGroup = row["SubjectLine"]?.trim()  // This is your dynamic part

    if (username && toEmail) {
        userEmailMap[username] = [to: toEmail, cc: ccEmail, support: supportGroup]
    }
}
inputMap.userEmailMap = userEmailMap

// Get all IPs from reference table
def rows = RefDataQuery.from("Linux_IPs_List").execute()
 
inputMap.RHEL5_IPList = rows.findAll { it["OSFlavor"] == "RHEL5" }*.IPAddress
inputMap.Linux_IPs_List =rows.findAll { it["OSFlavor"] == "Linux" }*.IPAddress
inputMap.RHEL7_IPList = rows.findAll { it["OSFlavor"] == "RHEL7" }*.IPAddress
inputMap.RHEL8_IPList = rows.findAll { it["OSFlavor"] == "RHEL8" }*.IPAddress
inputMap.RHEL9_IPList = rows.findAll { it["OSFlavor"] == "RHEL9" }*.IPAddress
inputMap.SLES15_IPList = rows.findAll { it["OSFlavor"] == "SLES15" }*.IPAddress
inputMap.SLES12_IPList = rows.findAll { it["OSFlavor"] == "SLES12" }*.IPAddress
inputMap.SLES11_IPList = rows.findAll { it["OSFlavor"] == "SLES11" }*.IPAddress
inputMap.Ubuntu22_IPList = rows.findAll { it["OSFlavor"] == "Ubuntu22" }*.IPAddress
inputMap.Ubuntu20_IPList = rows.findAll { it["OSFlavor"] == "Ubuntu20" }*.IPAddress
inputMap.CentOS8_IPList = rows.findAll { it["OSFlavor"] == "CentOS8" }*.IPAddress
inputMap.CentOS7_IPList = rows.findAll { it["OSFlavor"] == "CentOS7" }*.IPAddress
inputMap.CentOS6_IPList = rows.findAll { it["OSFlavor"] == "CentOS6" }*.IPAddress


/*
inputMap.RHEL5_IPList = []
inputMap.RHEL7_IPList = ["172.16.15.109"]
inputMap.RHEL8_IPList = ["172.30.32.186", "172.30.32.187"]
inputMap.RHEL9_IPList = ["172.16.9.63", "172.16.11.165", "172.16.11.162"]*/

/********************************************************************************************
* iWorkflow Use Case: Linux Password Expiry Report
*
* Description:
* This iWorkflow automates the process of collecting Linux user password expiry information
* from various Linux systems categorized by OS flavors (RHEL, SLES, Ubuntu, CentOS, etc).
* The workflow performs the following actions:
*   - Fetches recipient details and server IPs from reference data.
*   - Connects to each Linux server and retrieves password expiry information.
*   - Generates a consolidated CSV report.
*   - Sends reminder emails to users whose passwords are expiring in 15 days.
*   - Sends a final report to the Linux operations team.
*
* Flow Control:
*
* 1. PRE BLOCK
*    - Fetch current date, email recipients, user-email mappings, and IPs by OS flavor
*
* 2. INIT
*    - Initialize variables (IP lists, counters, report buffer, etc.)
*
* 3. MAIN LOGIC LOOP
*    - For each OS Flavor (SetNextFlavour)
*        - For each IP (CheckNextIP → getPwdExpiryDetails → NextIP)
*    - Loop continues until all IPs of all flavors are processed
*
* 4. SendIndividualMails
*    - Send email to each user if their password is expiring in 15 days
*
* 5. SendEmailReport
*    - Send final report to the Linux support team
*
* 6. END
*    - Mark the workflow as SUCCESS or ERROR with a summary
*
* Inputs:
*   - Reference Data Tables:
*     - Linux_IPs_List
*     - Linux_User_Email_Map
*     - Linux_Mail_Recipients
*
* Outputs:
*   - Consolidated password expiry CSV report.
*   - Individual user reminder emails.
*   - Summary email to the Linux support team.
*
* Author             : Chakravarthi Pulikonda
* Version            : 1.0
* Date Created       : 04-Aug-2025
* Last Modified By   : August 2025
* Last Modified      : August 2025
********************************************************************************************/

// ==============================================================================================================================
// Step: init
// Purpose:
// - Initialize all runtime variables.
// - Fetch input data from inputMap and store in processMap.
// - Prepare the Linux OS flavor list and their corresponding IP address lists.
// - Set counters for total, success, and failed IPs.
// - Initialize the CSV report header.
// ==============================================================================================================================
init {

    // Load metadata from inputMap
    currentdate   = inputMap.currentdate       // Current date for report timestamp
    emailCC       = inputMap.emailCC           // Email CC recipients
    emailTo       = inputMap.emailTo           // Email TO recipients
    emailsubject  = inputMap.emailsubject      // Email subject line
    
    // Define list of OS flavors to be processed

    flavours = ["RHEL5", "Linux", "RHEL7", "RHEL8", "RHEL9", "CentOS8" , "CentOS7" , "CentOS6" , "SLES15", "SLES12", "SLES11", "Ubuntu22", "Ubuntu20"]
    
    flavourIndex = 0        // Index to track current OS flavor
    index_ip     = 0       // Index to track current IP within the flavor list

    // Load IP lists for each OS flavor from Pre-Processing Block 
    rhel5List = inputMap.RHEL5_IPList
    LinuxList = inputMap.Linux_IPs_List
    rhel7List = inputMap.RHEL7_IPList
    rhel8List = inputMap.RHEL8_IPList
    rhel9List = inputMap.RHEL9_IPList
    SLES15List = inputMap.SLES15_IPList
    SLES12List = inputMap.SLES12_IPList
    SLES11List = inputMap.SLES11_IPList
    Ubuntu22_IPList = inputMap.Ubuntu22_IPList
    Ubuntu20_IPList = inputMap.Ubuntu20_IPList
    CentOS8_IPList = inputMap.CentOS8_IPList
    CentOS7_IPList = inputMap.CentOS7_IPList
    CentOS6_IPList = inputMap.CentOS6_IPList
    
    // Initialize counters for tracking progress
    totalIps    = 0       // Total number of IPs processed
    successIPs  = 0       // Number of successful executions
    failedIPs   = 0       // Number of failed executions
    
    // Initialize working variables
    IPList         = []       // Current list of IPs being processed
    currentFlavour = ""       // Current OS flavor being processed
    
    notifiedUsers = []
    individualUserList = [] // store list of users needing email
    
    // Initialize report header (CSV format)
    report = "Hostname,IP Address,User,Password Expiry Date,Last Password Change,Account Expiry Date,Expiring in 7 Days,Expiring in 15 Days,Expiry Status\n"

}
 
// ==============================================================================================================================
// Step: SetNextFlavour
// Purpose:
// - Set the current Linux OS flavor from the flavors list.
// - Load the corresponding IP list for that flavor.
// - Reset the index_ip to 0 for looping through IPs.
// ==============================================================================================================================

step("SetNextFlavour", StepType.ONIGNIO) {
    def flavour = processMap.flavours[processMap.flavourIndex]
    processMap.currentFlavour = flavour
    
    switch(flavour) {
        case "RHEL5":
            processMap.IPList = processMap.rhel5List
            LOG.error("Processing Linux Flavour : RHEL5")
            break
        case "Linux":
            processMap.IPList = processMap.LinuxList
            LOG.error("Processing Linux Flavour : Linux")
            break
        case "RHEL7":
            processMap.IPList = processMap.rhel7List
            LOG.error("Processing Linux Flavour : RHEL7")
            break
        case "RHEL8":
            processMap.IPList = processMap.rhel8List
            LOG.error("Processing Linux Flavour : RHEL8")
            break
        case "RHEL9":
            processMap.IPList = processMap.rhel9List
            LOG.error("Processing Linux Flavour : RHEL9")
            break
        case "SLES15":
            processMap.IPList = processMap.SLES15_IPList
            LOG.error("Processing Linux Flavour : SLES15")
            break
        case "SLES12":
            processMap.IPList = processMap.SLES12_IPList
            LOG.error("Processing Linux Flavour : SLES12")
            break
        case "SLES11":
            processMap.IPList = processMap.SLES11_IPList
            LOG.error("Processing Linux Flavour : SLES11")
            break
        case "Ubuntu22":
            processMap.IPList = processMap.Ubuntu22_IPList
            LOG.error("Processing Linux Flavour : SLES15")
            break
        case "Ubuntu20":
            processMap.IPList = processMap.Ubuntu20_IPList
            LOG.error("Processing Linux Flavour : Ubuntu")
            break
        case "CentOS8":
            processMap.IPList = processMap.CentOS8_IPList
            LOG.error("Processing Linux Flavour : CentOS8")
            break
        case "CentOS7":
            processMap.IPList = processMap.CentOS7_IPList
            LOG.error("Processing Linux Flavour : CentOS7")
            break
        case "CentOS6":
            processMap.IPList = processMap.CentOS6_IPList
            LOG.error("Processing Linux Flavour : CentOS6")
            break
    }
    
    processMap.index_ip = 0
}
.to({true}, "CheckNextIP")
 

// ==============================================================================================================================
// Step: CheckNextIP
// Purpose:
// - Check if there are more IPs to process for the current flavor.
// - If yes, go to getPwdExpiryDetails step.
// - If IPs are exhausted, move to the next flavor.
// - If all flavors processed, go to SendIndividualMails step.
// ==============================================================================================================================

step("CheckNextIP", StepType.ONIGNIO) {
    def ipCount = processMap.IPList.size()
    def flavourCount = processMap.flavours.size()
    if (processMap.index_ip < ipCount) {
        processMap.nextStep = "getPwdExpiryDetails"
    } else if (processMap.flavourIndex + 1 < flavourCount) {
        processMap.flavourIndex++
        processMap.nextStep = "SetNextFlavour"
    } else {
        processMap.nextStep = "SendIndividualMails"
    }
}
.to({ processMap.nextStep == "getPwdExpiryDetails" }, "getPwdExpiryDetails")
.to({ processMap.nextStep == "SetNextFlavour" }, "SetNextFlavour")
.to({ processMap.nextStep == "SendIndividualMails" }, "SendIndividualMails")
 
// ==============================================================================================================================
// Step: getPwdExpiryDetails
// Purpose:
// - Call the atomic function "Fetch_Pwd_Expiry_Details" on the current IP.
// - Pass required entity labels and values to the atomic function.
// ==============================================================================================================================

step("getPwdExpiryDetails", StepType.ONFUNCTION) {
    def ip = processMap.IPList[processMap.index_ip]
    Map<String, Object> entityMap = new HashMap<>()
    entityMap.put("IPAddress", ip)
    Set<String> entityLabels = new HashSet<>()
    entityLabels.add(processMap.currentFlavour)
    def entityInstance = ceb.get(entityLabels, entityMap)
    def entity = ceb.get(entityInstance.getId(), entityLabels)
    entity.Fetch_Pwd_Expiry_Details(ioutput: "output_report")
}
.to({true}, "NextIP")
 
// ==============================================================================================================================
// Step: NextIP
// Purpose:
// - Analyze the output from the atomic function.
// - If success: append the output to the report and collect usernames for individual mail.
// - If failed: log error and add a row in the report indicating failure.
// - Increment index_ip and totalIps counters.
// ==============================================================================================================================
step("NextIP", StepType.ONIGNIO) {
    def ip = (processMap.index_ip < processMap.IPList.size()) ? processMap.IPList[processMap.index_ip] : "Unknown IP"
    if (processMap.output_report?.outputStream) {
        processMap.successIPs += 1
        processMap.report += processMap.output_report.outputStream
 
        // Extract usernames who need individual mails (those marked 'Yes' in 'Expiring in 7 Days')
        def lines = processMap.output_report.outputStream.split("\\r?\\n")
        for (line in lines) {
            def cols = line.split(",")
            if (cols.size() >= 8 && cols[7].trim().toLowerCase() == "yes") {
                def username = cols[2].trim()
                def IP = cols[1].trim()
                def hostname = cols[0].trim()
                if (username) {
                    processMap.individualUserList.add(username)
                }
            }
        }
 
    } else {
        def errStream = processMap.output_report?.errorStream ?: "Unknown Error"
        errStream = errStream.replaceAll("[\\r\\n]+", " ").replace(",", " ")
        processMap.report += "Unknown," + ip + ",Unknown," + errStream + "Error,Error,Error,Error,Error\n"
        
        processMap.failedIPs += 1
    }
    
    LOG.error("Processed IP: " + ip)    
    processMap.index_ip++
    processMap.totalIps += 1
}
.to({true}, "CheckNextIP")
 

// ==============================================================================================================================
// Step: SendIndividualMails
// Purpose:
// - For each user in the report, check if their password is expiring in 15 days.
// - If so, send an individual reminder email using the userEmailMap (To and CC).
// - Log the usernames to whom individual emails are sent.
// ==============================================================================================================================
// New step - send mail to each user individually
/*step("SendIndividualMails", StepType.ONIGNIO) {
    def lines = processMap.report.readLines()
    def userEmailMap = inputMap.userEmailMap
    for (int i = 1; i < lines.size(); i++) {
        def columns = lines[i].split(",", -1)
        def username = columns[2]?.trim()
        def lookupKey = username?.toLowerCase()
        def IP = columns[1]?.trim()
        def hostname = columns[0]?.trim()
        def expiringIn15Days = columns[7]?.trim()?.toLowerCase()
     
        LOG.error("Checking line: "+lines[i])
        LOG.error("User: "+username+", Expiring in 15 Days: "+expiringIn15Days)
     
        if (expiringIn15Days == "yes" && userEmailMap.containsKey(lookupKey)) {
            def emailInfo = userEmailMap[lookupKey]
            def emailTo = emailInfo.to
            def emailCC = emailInfo.cc ?: ""
            def emailBody = """
            <html>
              <body style="font-family: Arial, sans-serif; font-size: 14px; color: #333333;">
                <p>
                  Dear """ + username + """,
                  <br><br>
                  This is a gentle reminder that your <b>Linux password will expire in 15 days</b>.
                  <br><br>
                </p>
             
                <table cellpadding="6" cellspacing="0" border="0" style="background-color: #f9f9f9; border: 1px solid #dddddd; border-radius: 6px;">
                  <tr>
                    <td><b>Hostname:</b></td>
                    <td>""" + hostname + """</td>
                  </tr>
                  <tr>
                    <td><b>IP Address:</b></td>
                    <td>""" + IP + """</td>
                  </tr>
                  <tr>
                    <td><b>Username:</b></td>
                    <td>""" + username + """</td>
                  </tr>
                </table>
             
                <br>
                Kindly reset your password to avoid access issues.
                <br><br>
                Regards,<br>
                <b>Team ignio</b>
                <br><br>
                <hr style="border: none; border-top: 1px solid #cccccc; margin: 20px 0;">
                <p style="color: #888888;"><i>Note: This is an automated mail. Please do not reply.</i></p>
              </body>
            </html>
            """
     
            iAction.Collaboration.SendMail(
                Body: emailBody,
                Subject: "Linux Password Expiry Reminder for "+username+" on IP Address :"+IP+" - 15 Days Left",
                To: emailTo,
                CC: emailCC
            )
            processMap.notifiedUsers.add(username)
            LOG.error("Sent individual reminder to: " + username + " (To: " + emailTo + ", CC: " + emailCC + ")")
        }
    }
 
}
.to({true}, "SendEmailReport")*/

step("SendIndividualMails", StepType.ONIGNIO) {
    def lines = processMap.report.readLines()
    def userEmailMap = inputMap.userEmailMap

    for (int i = 1; i < lines.size(); i++) {
        def columns = lines[i].split(",", -1)
        def username = columns[2]?.trim()
        def lookupKey = username?.toLowerCase()
        def IP = columns[1]?.trim()
        def hostname = columns[0]?.trim()
        def expiringIn15Days = columns[7]?.trim()?.toLowerCase()

        LOG.error("Checking line: " + lines[i])
        LOG.error("User: " + username + ", Expiring in 15 Days: " + expiringIn15Days)

        if (expiringIn15Days == "yes" && userEmailMap.containsKey(lookupKey)) {
            def emailInfo = userEmailMap[lookupKey]
            def emailTo = emailInfo.to
            def emailCC = emailInfo.cc ?: ""
            def supportGroup = emailInfo.support ?: "Support"

            def finalSubject = "Linux Password Expiry Reminder - " + supportGroup + " - for " + username + " on IP Address :" + IP + " - 15 Days Left"

            def emailBody = """
            <html>
              <body style="font-family: Arial, sans-serif; font-size: 14px; color: #333333;">
                <p>
                  Dear """ + username + """,
                  <br><br>
                  This is a gentle reminder that your <b>Linux password will expire in 15 days</b>.
                  <br><br>
                </p>
             
                <table cellpadding="6" cellspacing="0" border="0" style="background-color: #f9f9f9; border: 1px solid #dddddd; border-radius: 6px;">
                  <tr>
                    <td><b>Hostname:</b></td>
                    <td>""" + hostname + """</td>
                  </tr>
                  <tr>
                    <td><b>IP Address:</b></td>
                    <td>""" + IP + """</td>
                  </tr>
                  <tr>
                    <td><b>Username:</b></td>
                    <td>""" + username + """</td>
                  </tr>
                </table>
             
                <br>
                Kindly reset your password to avoid access issues.
                <br><br>
                Regards,<br>
                <b>Team ignio</b>
                <br><br>
                <hr style="border: none; border-top: 1px solid #cccccc; margin: 20px 0;">
                <p style="color: #888888;"><i>Note: This is an automated mail. Please do not reply.</i></p>
              </body>
            </html>
            """

            iAction.Collaboration.SendMail(
                Body: emailBody,
                Subject: finalSubject,
                To: emailTo,
                CC: emailCC
            )

            processMap.notifiedUsers.add(username)
            LOG.error("Sent individual reminder to: " + username + " (To: " + emailTo + ", CC: " + emailCC + ", Subject: " + finalSubject + ")")
        }
    }
}
.to({true}, "SendEmailReport")

 

// ==============================================================================================================================
// Step: SendEmailReport
// Purpose:
// - Compose and send the final consolidated password expiry report to the Linux team.
// - If the report file size exceeds the threshold (10MB), send an alternate notification.
// - Clean up the generated file after sending.
// ==============================================================================================================================
step("SendEmailReport", StepType.ONIGNIO) {
    def date = processMap.currentdate
    def emailBody = """
    <html>
          <body> Dear Team,
            <br><br> Please find attached the <b>Linux Password Expiry Report</b> as of <b>""" + date + """</b>.<br>
            <h3>Linux Password Expiry Users Summary</h3>
        <table cellpadding="6" cellspacing="0" border="0" style="background-color: #f9f9f9; border: 1px solid #dddddd; border-radius: 6px;">
                  <tr>
                    <td><b>Success Count:</b></td>
                    <td>""" + processMap.successIPs + """</td>
                  </tr>
                  <tr>
                    <td><b>Failure Count:</b></td>
                    <td>""" + processMap.failedIPs + """</td>
                  </tr>
                  <tr>
                    <td><b>Total Count:</b></td>
                    <td>""" + processMap.totalIps + """</td>
                  </tr>
         </table><br>
         
              <br> Thank You,
                <br> Team ignio<br><br> 
                <hr style="border: none; border-top: 1px solid #cccccc; margin: 20px 0;">
                  <i style="color: #888888;">Note: This is an automatically generated mail. Please do not reply.</i> 
            </body>
    </html>"""
    def reportName = "LinuxPwdExpiryReport_" + date + ".csv"
    def file = new File(reportName)
    file.write(processMap.report)
    file.setReadOnly()
 LOG.error("Email subject date"+processMap.emailsubject)
    def MAX_SIZE = 9990000L
    def fileSize = file.size()
    if (fileSize < MAX_SIZE) {
        org.springframework.web.multipart.MultipartFile[] filesForAttachment = fileUtils.createMultiPartFileFromFile(file)
        iAction.Collaboration.SendMail(
            Body: emailBody,
            Subject: processMap.emailsubject,
            To: processMap.emailTo,
            CC: processMap.emailCC,
            hasAttachment: filesForAttachment
        )
        LOG.error("Email sent successfully with attachment.")
        processMap.status = 0
    } else {
        mailBody="""
        <html>
          <body style="font-family: Arial, sans-serif; font-size: 14px; color: #333333;">
            <p>
              Dear Team,
              <br><br>
              This is to inform you that the <b>Linux Password Expiry Report</b> could not be attached as the file size exceeded the permissible email limit (10MB).
              <br><br>
              Kindly reach out to the <b>Linux Support Team</b>.
              <br><br>
              <b>Report Date:</b> """ + date + """
              <br><br>
              
              <h3>Linux Password Expiry Users Summary</h3>
        <table cellpadding="6" cellspacing="0" border="0" style="background-color: #f9f9f9; border: 1px solid #dddddd; border-radius: 6px;">
                  <tr>
                    <td><b>Success Count:</b></td>
                    <td>""" + processMap.successIPs + """</td>
                  </tr>
                  <tr>
                    <td><b>Failure Count:</b></td>
                    <td>""" + processMap.failedIPs + """</td>
                  </tr>
                  <tr>
                    <td><b>Total Count:</b></td>
                    <td>""" + processMap.totalIps + """</td>
                  </tr>
         </table><br>
         
              Thank you,<br>
              <b>Team ignio</b>
            </p>
            <hr style="border: none; border-top: 1px solid #cccccc; margin: 20px 0;">
            <p style="color: #888888;"><i>Note: This is an automatically generated mail. Please do not reply.</i></p>
          </body>
        </html>
        """
        iAction.Collaboration.SendMail(
            Body: mailBody,
            Subject: processMap.emailsubject,
            To: processMap.emailTo,
            CC: processMap.emailCC
        )
        LOG.error("Attachment too large to send: " + fileSize)
        processMap.status = 1
    }
    file.delete()
}
.to({ processMap.status == 0 }, "SUCCESS")
.elseTo("ERROR")
 

// ==============================================================================================================================
// End States SUCCESS / ERROR
// Purpose:
//   - Return a success/ failure message with summary counts (success, failure, total).
// ==============================================================================================================================
end("SUCCESS", Status.SUCCESS) {
    outputMap << [outputStream: "Linux password expiry report mail sent successfully.\nSuccess Count: " + processMap.successIPs + "\nFailure Count: " + processMap.failedIPs + "\nTotal Count: " + processMap.totalIps ] // + "\nIndividual Mail Sent To: " + processMap.notifiedUsers.join(", ")]
}
 
end("ERROR", Status.ERROR) {
    outputMap << [outputStream: "Failed to send Linux password expiry report.\nSuccess Count: " + processMap.successIPs + "\nFailure Count: " + processMap.failedIPs + "\nTotal Count: " + processMap.totalIps]
}


/*
// Main code of iworkflow
init {
    currentdate = inputMap.currentdate
    //emailTo = inputMap.emailTo
    emailCC = inputMap.emailCC
    emailsubject = inputMap.Emailsubject
 
    flavours = ["RHEL5", "RHEL7", "RHEL8", "RHEL9"]
    flavourIndex = 0
    index_ip = 0
 
    rhel5List = inputMap.RHEL5_IPList
    rhel7List = inputMap.RHEL7_IPList
    rhel8List = inputMap.RHEL8_IPList
    rhel9List = inputMap.RHEL9_IPList
 
    totalIps = 0
    successIPs = 0
    failedIPs = 0
 
    IPList = []
    currentFlavour = ""
    //report = "Hostname,IP Address,User,Password Expiry Date,Year\n"
    report = "Hostname,IP Address,User,Password Expiry Date,Last Password Change,Account Expiry Date,Expiring in 7 Days,Expiring in 15 Days,Expiry Status\n" // CSV Headers
 
}
 
step("SetNextFlavour", StepType.ONIGNIO) {
    def flavour = processMap.flavours[processMap.flavourIndex]
    processMap.currentFlavour = flavour
 
    switch(flavour) {
        case "RHEL5":
            processMap.IPList = processMap.rhel5List
            LOG.error("Processing Linux Flavour : RHEL5")
            break
        case "RHEL7":
            processMap.IPList = processMap.rhel7List
            LOG.error("Processing Linux Flavour : RHEL7")
            break
        case "RHEL8":
            processMap.IPList = processMap.rhel8List
            LOG.error("Processing Linux Flavour : RHEL8")
            break
        case "RHEL9":
            processMap.IPList = processMap.rhel9List
            LOG.error("Processing Linux Flavour : RHEL9")
            break
    }
 
    processMap.index_ip = 0
}
.to({true}, "CheckNextIP")
 
step("CheckNextIP", StepType.ONIGNIO) {
    def ipCount = processMap.IPList.size()
    def flavourCount = processMap.flavours.size()
 
    if (processMap.index_ip < ipCount) {
        processMap.nextStep = "getPwdExpiryDetails"
    } else if (processMap.flavourIndex + 1 < flavourCount) {
        processMap.flavourIndex++
        processMap.nextStep = "SetNextFlavour"
    } else {
        processMap.nextStep = "SendEmailReport"
    }
}
.to({ processMap.nextStep == "getPwdExpiryDetails" }, "getPwdExpiryDetails")
.to({ processMap.nextStep == "SetNextFlavour" }, "SetNextFlavour")
.to({ processMap.nextStep == "SendEmailReport" }, "SendEmailReport")
 
// Fetch data from atomic function
step("getPwdExpiryDetails", StepType.ONFUNCTION) {
    def ip = processMap.IPList[processMap.index_ip]
 
    Map<String, Object> entityMap = new HashMap<>()
    entityMap.put("IPAddress", ip)
 
    Set<String> entityLabels = new HashSet<>()
    entityLabels.add(processMap.currentFlavour)
 
    def entityInstance = ceb.get(entityLabels, entityMap)
    def entity = ceb.get(entityInstance.getId(), entityLabels)
 
    entity.Fetch_Pwd_Expiry_Details(ioutput: "output_report")
}
.to({true}, "NextIP")
 
step("NextIP", StepType.ONIGNIO) {
    def ip = (processMap.index_ip < processMap.IPList.size()) ? processMap.IPList[processMap.index_ip] : "Unknown IP"
 
    if (processMap.output_report?.outputStream) {
        processMap.successIPs += 1
processMap.report += processMap.output_report.outputStream
    } else {
        //processMap.failedIPs += 1
        //processMap.report += "Unknown," + ip + ",Error,Error\n"
        def errStream = processMap.output_report?.errorStream ?: "Unknown Error"
        errStream = errStream.replaceAll("[\\r\\n]+", " ").replace(",", " ")
        processMap.report += "Unknown," + ip + "," + errStream + "\n"
    }
 
    LOG.error("Processed IP: " + ip)
    processMap.index_ip++
    processMap.totalIps += 1
}
.to({true}, "CheckNextIP")
 
step("SendEmailReport", StepType.ONIGNIO) {
    def date = processMap.currentdate
    def emailBody = """
        <html><body>
        Dear Team,<br><br>
        Please find attached the <b>Linux Password Expiry Report</b> as of <b>""" +date+ """</b>.<br><br>
        Thank You,<br>
        Team ignio<br><br>
        <b>Note: This is an automatically generated mail. Please do not reply.</b>
        </body></html>
    """
 
    def reportName = "LinuxPwdExpiryReport_" +date+ ".csv"
    def file = new File(reportName)
file.write(processMap.report)
    file.setReadOnly()
 
    def MAX_SIZE = 10000000L
    def fileSize = file.size()
    
    def emailTo = "priyanka.gourabathuni@digitate.com,chakravarthypulikonda.tcs@sunpharma.com"
    //def emailCC = "chakravarthi.pulikonda@tcs.com"

    if (fileSize < MAX_SIZE) {
        org.springframework.web.multipart.MultipartFile[] filesForAttachment = fileUtils.createMultiPartFileFromFile(file)
        iAction.Collaboration.SendMail(
            Body: emailBody,
            Subject: processMap.emailsubject,
            To: processMap.emailTo,
            CC: processMap.emailCC,
            hasAttachment: filesForAttachment
        )
        LOG.error("Email sent successfully with attachment.")
        processMap.status = 0
    } else {
        LOG.error("Attachment too large to send: " + fileSize)
        processMap.status = 1
    }
 
    file.delete()
}
.to({ processMap.status == 0 }, "SUCCESS")
.elseTo("ERROR")
 
end("SUCCESS", Status.SUCCESS) {
    outputMap << [outputStream: "Linux password expiry report mail sent successfully.\nSuccess Count: "+processMap.successIPs+"\nFailure Count: "+processMap.failedIPs+"\nTotal Count: " +processMap.totalIps]
}
 
end("ERROR", Status.ERROR) {
    outputMap << [outputStream: "Failed to send Linux password expiry report.\nSuccess Count: "+processMap.successIPs+"\nFailure Count: "+processMap.failedIPs+"\nTotal Count: "+processMap.totalIps]
}


*/